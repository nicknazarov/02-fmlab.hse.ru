#clear working environment
rm(list=ls())
source("reality_func2.R")
###########################################################################################
#4) Четвертая часть -  reality check с разбивкой на процентили (50%, 30%, 20%, 10%)
library(XLConnect)
# Загружаем ранее сохраненные цены закрытия
#resultDataFull<- readWorksheet(loadWorkbook("stocks_india.xlsx"),sheet=1)
#resultDataFull <- read.csv(file="stocks_china.csv", header=TRUE)
resultDataFull <-  read.csv("data/stocks_malaysia.csv")
row.names(resultDataFull) <- resultDataFull[,1]
resultDataFull <-resultDataFull[,-1]
# Шаг для подсчета разниц в группах победителей и проигравших
STEP=1
# Периоды отбора (в месяцах), удержания (в неделях), инвестирования (в месяцах)
UP1=48
UP2=8
UP3=48
#UP1=2
#UP2=2
#UP3=2
# N - с учетом отступа
N <- (nrow(resultDataFull)-(2+UP3*4))%/%STEP
#N 227
########################Константы для reality check
R <- 1
#
#T <- 164
T <- 86
N_rc <- 500
Q <- 0.1
#n <- T-R+1
temp <- ret(4, 1, 4, STEP, N, resultDataFull[,-1], UP1, UP2, 0.3)
source("reality_func2.R")
(
source("R/reality_func2.R")
temp <- ret(4, 1, 4, STEP, N, resultDataFull[,-1], UP1, UP2, 0.3)
###########################################################################################
#1) Первая часть — очистка рабочего пространства, задание раб директории
#setwd("/home/nazarov/02-fmlab.hse.ru/ТЗ до 29.07.2015/With zero/")
setwd("/home/nazarov/02-fmlab.hse.ru/05 - reverse/")
#setwd("J:/12 - ЛАФР/02 - Декомпозиция")
#clear working environment
rm(list=ls())
source("R/reality_func2.R")
###########################################################################################
#4) Четвертая часть -  reality check с разбивкой на процентили (50%, 30%, 20%, 10%)
library(XLConnect)
# Загружаем ранее сохраненные цены закрытия
#resultDataFull<- readWorksheet(loadWorkbook("stocks_india.xlsx"),sheet=1)
#resultDataFull <- read.csv(file="stocks_china.csv", header=TRUE)
resultDataFull <-  read.csv("data/stocks_malaysia.csv")
row.names(resultDataFull) <- resultDataFull[,1]
resultDataFull <-resultDataFull[,-1]
# перебор от 1 до 12 мес , ждем от 0 до 8 недель, держим от 1 до 12 мес
# таким образом  последние 25 месяцев понадобятся только для одной модели
# Шаг для подсчета разниц в группах победителей и проигравших
STEP=1
# Периоды отбора (в месяцах), удержания (в неделях), инвестирования (в месяцах)
UP1=48
UP2=8
UP3=48
#UP1=2
#UP2=2
#UP3=2
# N - с учетом отступа
N <- (nrow(resultDataFull)-(2+UP3*4))%/%STEP
#N 227
########################Константы для reality check
R <- 1
#
#temp <- ret(4, 1, 4, STEP, N, resultDataFull[,-1], UP1, UP2, 0.3)
#T <- 164
T <- 297
N_rc <- 500
Q <- 0.1
#n <- T-R+1
set.seed(42)
P_R_ind <- data.frame(P_R(R,T,Q))
for (i in 2:N_rc){
P_R_ind[,i]  <-  P_R(R,T,Q)
}
V_star <- c()
f_bar  <- c()
V_star_sharp <- c()
f_sharp  <- c()
########################
m <- 1
realityCheckData <- data.frame(1,1,1,1,1,1,1,1,1,1)
colnames(realityCheckData) <-c("mean","t","p-value","hist_per","moment_per","invest_per","percent","winners","losers", "Amount_of_negative")
for (percent in c(0.5,0.3,0.2,0.1) ){
for (p1 in 1:UP1 ){
for (p2 in 0:UP2 ){
for (p3 in 1:UP3 ){
#вектор дельт
temp <- ret(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
return.winner<- ret.winner(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
return.loser<- ret.loser(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
n <- length(temp)
#realityCheckData[m, ] <- list(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, percent,
#                              mean(return.winner), mean(return.loser))
#cat(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, n, percent, mean(return.winner), mean(return.loser), "\n")
realityCheckData[m, ] <- list(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, percent,
mean(return.winner), mean(return.loser),length(temp[temp<0]))
cat(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, n, percent, mean(return.winner), mean(return.loser),length(temp[temp<0]), "\n")
#############################################################REALITY_CHECK##########################################################################
temp <- temp-0.06/12
f_bar <- mean(temp)
if(m==1){
V_bar <- sqrt(n)*mean(temp)
for (k in 1:N_rc){
V_star[k] <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
}
}
else {
V_bar <- max(sqrt(n)*f_bar,V_bar)
for (k in 1:N_rc){
t <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
V_star[k] <-max(t,V_star[k])
}
}
retBoot <- c(V_star,V_bar)
realityCheckData[m, "pBoot"] <- 1-(rank(retBoot, ties.method = "first")[501]-1)/500
#  list(V_bar,V_star)
####################################################################################################################################################
#############################################################REALITY_CHECK - SHARP##################################################################
f_sharp <- mean(temp)/sd(temp)
if(m==1){
V_bar_sharp <- sqrt(n)*f_sharp
for (k in 1:N_rc){
#     V_star[k] <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
V_star_sharp[k] <- sqrt(n)*(mean(temp[P_R_ind[,k]])/sd(temp[P_R_ind[,k]]) - f_sharp)
}
}
else {
V_bar_sharp <- max(sqrt(n)* f_sharp ,V_bar_sharp)
for (k in 1:N_rc){
#      t <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
t <- sqrt(n)*(mean(temp[P_R_ind[,k]])/sd(temp[P_R_ind[,k]]) - f_sharp)
V_star_sharp[k] <-max(t,V_star_sharp[k])
}
}
retBoot.sharp <- c(V_star_sharp,V_bar_sharp)
realityCheckData[m, "pBoot-Sharp"] <- 1-(rank(retBoot.sharp, ties.method = "first")[501]-1)/500
#  list(V_bar,V_star)
####################################################################################################################################################
m <- m+1
}
}
}
}
# Загружаем ранее сохраненные цены закрытия
#resultDataFull<- readWorksheet(loadWorkbook("stocks_india.xlsx"),sheet=1)
#resultDataFull <- read.csv(file="stocks_china.csv", header=TRUE)
resultDataFull <-  read.csv("data/stocks_malaysia.csv")
row.names(resultDataFull) <- resultDataFull[,1]
resultDataFull <-resultDataFull[,-1]
# перебор от 1 до 12 мес , ждем от 0 до 8 недель, держим от 1 до 12 мес
# таким образом  последние 25 месяцев понадобятся только для одной модели
# Шаг для подсчета разниц в группах победителей и проигравших
STEP=1
# Периоды отбора (в месяцах), удержания (в неделях), инвестирования (в месяцах)
UP1=12
UP2=8
UP3=12
#UP1=2
#UP2=2
#UP3=2
# N - с учетом отступа
N <- (nrow(resultDataFull)-(2+UP3*4))%/%STEP
#N 227
########################Константы для reality check
R <- 1
#
#temp <- ret(4, 1, 4, STEP, N, resultDataFull[,-1], UP1, UP2, 0.3)
#T <- 164
T <- 297
N_rc <- 500
Q <- 0.1
#n <- T-R+1
set.seed(42)
P_R_ind <- data.frame(P_R(R,T,Q))
for (i in 2:N_rc){
P_R_ind[,i]  <-  P_R(R,T,Q)
}
V_star <- c()
f_bar  <- c()
V_star_sharp <- c()
f_sharp  <- c()
########################
m <- 1
realityCheckData <- data.frame(1,1,1,1,1,1,1,1,1,1)
colnames(realityCheckData) <-c("mean","t","p-value","hist_per","moment_per","invest_per","percent","winners","losers", "Amount_of_negative")
for (percent in c(0.5,0.3,0.2,0.1) ){
for (p1 in 1:UP1 ){
for (p2 in 0:UP2 ){
for (p3 in 1:UP3 ){
#вектор дельт
temp <- ret(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
return.winner<- ret.winner(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
return.loser<- ret.loser(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
n <- length(temp)
#realityCheckData[m, ] <- list(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, percent,
#                              mean(return.winner), mean(return.loser))
#cat(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, n, percent, mean(return.winner), mean(return.loser), "\n")
realityCheckData[m, ] <- list(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, percent,
mean(return.winner), mean(return.loser),length(temp[temp<0]))
cat(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, n, percent, mean(return.winner), mean(return.loser),length(temp[temp<0]), "\n")
#############################################################REALITY_CHECK##########################################################################
temp <- temp-0.06/12
f_bar <- mean(temp)
if(m==1){
V_bar <- sqrt(n)*mean(temp)
for (k in 1:N_rc){
V_star[k] <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
}
}
else {
V_bar <- max(sqrt(n)*f_bar,V_bar)
for (k in 1:N_rc){
t <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
V_star[k] <-max(t,V_star[k])
}
}
retBoot <- c(V_star,V_bar)
realityCheckData[m, "pBoot"] <- 1-(rank(retBoot, ties.method = "first")[501]-1)/500
#  list(V_bar,V_star)
####################################################################################################################################################
#############################################################REALITY_CHECK - SHARP##################################################################
f_sharp <- mean(temp)/sd(temp)
if(m==1){
V_bar_sharp <- sqrt(n)*f_sharp
for (k in 1:N_rc){
#     V_star[k] <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
V_star_sharp[k] <- sqrt(n)*(mean(temp[P_R_ind[,k]])/sd(temp[P_R_ind[,k]]) - f_sharp)
}
}
else {
V_bar_sharp <- max(sqrt(n)* f_sharp ,V_bar_sharp)
for (k in 1:N_rc){
#      t <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
t <- sqrt(n)*(mean(temp[P_R_ind[,k]])/sd(temp[P_R_ind[,k]]) - f_sharp)
V_star_sharp[k] <-max(t,V_star_sharp[k])
}
}
retBoot.sharp <- c(V_star_sharp,V_bar_sharp)
realityCheckData[m, "pBoot-Sharp"] <- 1-(rank(retBoot.sharp, ties.method = "first")[501]-1)/500
#  list(V_bar,V_star)
####################################################################################################################################################
m <- m+1
}
}
}
}
temp <- ret(4, 1, 4, STEP, N, resultDataFull[,-1], UP1, UP2, 0.3)
#clear working environment
rm(list=ls())
source("R/reality_func2.R")
###########################################################################################
#4) Четвертая часть -  reality check с разбивкой на процентили (50%, 30%, 20%, 10%)
library(XLConnect)
# Загружаем ранее сохраненные цены закрытия
#resultDataFull<- readWorksheet(loadWorkbook("stocks_india.xlsx"),sheet=1)
#resultDataFull <- read.csv(file="stocks_china.csv", header=TRUE)
resultDataFull <-  read.csv("data/stocks_malaysia.csv")
row.names(resultDataFull) <- resultDataFull[,1]
resultDataFull <-resultDataFull[,-1]
# перебор от 1 до 12 мес , ждем от 0 до 8 недель, держим от 1 до 12 мес
# таким образом  последние 25 месяцев понадобятся только для одной модели
# Шаг для подсчета разниц в группах победителей и проигравших
STEP=1
# Периоды отбора (в месяцах), удержания (в неделях), инвестирования (в месяцах)
UP1=12
UP2=8
UP3=12
#UP1=2
#UP2=2
#UP3=2
# N - с учетом отступа
N <- (nrow(resultDataFull)-(2+UP3*4))%/%STEP
#N 227
########################Константы для reality check
R <- 1
#
#temp <- ret(4, 1, 4, STEP, N, resultDataFull[,-1], UP1, UP2, 0.3)
#T <- 164
#T <- 297
T <- 585
N_rc <- 500
Q <- 0.1
#n <- T-R+1
set.seed(42)
P_R_ind <- data.frame(P_R(R,T,Q))
for (i in 2:N_rc){
P_R_ind[,i]  <-  P_R(R,T,Q)
}
V_star <- c()
f_bar  <- c()
V_star_sharp <- c()
f_sharp  <- c()
########################
m <- 1
realityCheckData <- data.frame(1,1,1,1,1,1,1,1,1,1)
colnames(realityCheckData) <-c("mean","t","p-value","hist_per","moment_per","invest_per","percent","winners","losers", "Amount_of_negative")
for (percent in c(0.5,0.3,0.2,0.1) ){
for (p1 in 1:UP1 ){
for (p2 in 0:UP2 ){
for (p3 in 1:UP3 ){
#вектор дельт
temp <- ret(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
return.winner<- ret.winner(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
return.loser<- ret.loser(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
n <- length(temp)
#realityCheckData[m, ] <- list(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, percent,
#                              mean(return.winner), mean(return.loser))
#cat(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, n, percent, mean(return.winner), mean(return.loser), "\n")
realityCheckData[m, ] <- list(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, percent,
mean(return.winner), mean(return.loser),length(temp[temp<0]))
cat(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, n, percent, mean(return.winner), mean(return.loser),length(temp[temp<0]), "\n")
#############################################################REALITY_CHECK##########################################################################
temp <- temp-0.06/12
f_bar <- mean(temp)
if(m==1){
V_bar <- sqrt(n)*mean(temp)
for (k in 1:N_rc){
V_star[k] <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
}
}
else {
V_bar <- max(sqrt(n)*f_bar,V_bar)
for (k in 1:N_rc){
t <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
V_star[k] <-max(t,V_star[k])
}
}
retBoot <- c(V_star,V_bar)
realityCheckData[m, "pBoot"] <- 1-(rank(retBoot, ties.method = "first")[501]-1)/500
#  list(V_bar,V_star)
####################################################################################################################################################
#############################################################REALITY_CHECK - SHARP##################################################################
f_sharp <- mean(temp)/sd(temp)
if(m==1){
V_bar_sharp <- sqrt(n)*f_sharp
for (k in 1:N_rc){
#     V_star[k] <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
V_star_sharp[k] <- sqrt(n)*(mean(temp[P_R_ind[,k]])/sd(temp[P_R_ind[,k]]) - f_sharp)
}
}
else {
V_bar_sharp <- max(sqrt(n)* f_sharp ,V_bar_sharp)
for (k in 1:N_rc){
#      t <- sqrt(n)*(mean(temp[P_R_ind[,k]]) - f_bar)
t <- sqrt(n)*(mean(temp[P_R_ind[,k]])/sd(temp[P_R_ind[,k]]) - f_sharp)
V_star_sharp[k] <-max(t,V_star_sharp[k])
}
}
retBoot.sharp <- c(V_star_sharp,V_bar_sharp)
realityCheckData[m, "pBoot-Sharp"] <- 1-(rank(retBoot.sharp, ties.method = "first")[501]-1)/500
#  list(V_bar,V_star)
####################################################################################################################################################
m <- m+1
}
}
}
}
stuff <- list(data=realityCheckData, num=N, V_bar=V_bar,V_star=V_star, V_bar_sharp=V_bar_sharp,V_star_sharp=V_star_sharp)  # список ценных объектов
saveRDS(file = "malaysia_zero_16.12.RDS",stuff) # сохраняем всё ценное в файл
dd <- realityCheckData[ (realityCheckData$percent==0.5)  ,]
head( realityCheckData[order(- realityCheckData[,1]) ,],10)
head( realityCheckData[order(- realityCheckData[,2]) ,],10)
res_sh3 <- head(mylist$data[order(-mylist$data[,1]) ,],20) # просматриваем лучшие результаты
head( realityCheckData[order(- realityCheckData[,1]) ,-8],20)
setwd("~/02-fmlab.hse.ru/05 - reverse/results")
resultDataFull<- readWorksheet(loadWorkbook("/home/nazarov/02-fmlab.hse.ru/05 - reverse/data/stocks_malaysia.xlsx"),sheet=1)
setwd("/nazarov")
setwd("/home/nazarov/")
setwd("~/")
resultDataFull<- readWorksheet(loadWorkbook("stocks_malaysia.xlsx"),sheet=1)
library(XLConnect)
resultDataFull<- readWorksheet(loadWorkbook("stocks_malaysia.xlsx"),sheet=1)
library(plotly)
install.packages("plotly")
install.packages(c("broom", "caret", "coin", "curl", "ggplot2", "git2r", "jsonlite", "lubridate", "manipulate", "Matrix", "pander", "party", "pbkrtest", "Rcpp", "RcppArmadillo", "rmarkdown", "roxygen2", "rstudioapi", "sjmisc", "stringi", "texreg", "xtable"))
install.packages("plotly")
install.packages("plotly")
install.packages(c("ggplot2", "manipulate"))
install.packages("ggplot2")
install.packages('ggplot2', dep = TRUE)
install.packages("plotly")
install.packages("ggplot2")
install.packages("proto")
install.packages("ggplot2")
sessionInfo()
shiny::runApp('01-projects/task_11_data_set/koh')
shiny::runApp('01-projects/task_11_data_set/koh')
shiny::runApp('01-projects/task_11_data_set/koh')
shiny::runApp('01-projects/task_11_data_set/koh')
library(AppliedPredictiveModeling)
library(caret)
data(AlzheimerDisease)
library(XLConnect)
#library(DT)
#panderOptions('table.split.table', Inf)
#library(ggplot2)
#library(scales)
setwd("/home/nazarov/02-fmlab.hse.ru/05 - reverse/")
source("R/reality_func2.R")
#############################################################################
# Параметры, которые зависят от изучаемой страны
country_name_eng <- "malaysia"
#N <- (nrow(price_d5)-(2+UP3*4))%/%STEP
#temp <-  ret(4, 0, 4, STEP, N, price_d5, UP1, UP2, 0.1)
#malaysia
T <- 537
#############################################################################
# Загрузка
price_d5<- readWorksheet(loadWorkbook("data/5 days malaysia/malaysia_price_Fri.xlsx"),sheet=1)
#############################################################################
#price_d5<- readWorksheet(loadWorkbook("data/5 days malaysia/malaysia_price_Fri.xlsx"),sheet=1)
row.names(price_d5) <- price_d5[,1]
price_d5 <-price_d5[,-1]
#############################################################################
# Константы
# перебор от 1 до 12 мес , ждем от 0 до 8 недель, держим от 1 до 24 мес
# таким образом  последние 25 месяцев понадобятся только для одной модели
# Шаг для подсчета разниц в группах победителей и проигравших
STEP=1
# Периоды отбора (в месяцах), удержания (в неделях), инвестирования (в месяцах)
UP1=12
UP2=8
UP3=24
# N - с учетом отступа
#n <- T-R+1
#############################################################################
# Процедура формирования портфелей, подсчета статистик и bootstrap
start_time <- Sys.time()
m <- 1
realityCheckData <- data.frame(1,1,1,1,1,1,1,1,1,1)
colnames(realityCheckData) <-c("mean","t","p-value","hist_per","moment_per","invest_per","percent","winners","losers", "Amount_of_negative")
resultDataFull <- price_d5
N <- (nrow(resultDataFull)-(2+UP3*4))%/%STEP
library(parallel)
#nn.p<-function()
#{
print("Параллельное выполнение")
cl <- makeCluster(getOption("cl.cores", 4)) # создание кластера из четырёх ядер процессора
clusterExport(cl,"infert") # передача данных внутрь кластера
clusterEvalQ(cl,source("R/reality_func2.R")) # загрузка функций в кластер
#clusterExport(cl, "UP1", "UP2", "UP3", "STEP", "resultDataFull", "N")
start_time <- Sys.time()
parSapply(cl,  c(0.5,0.3,0.2,0.1), function(percent, UP1, UP2, UP3, STEP, resultDataFull,realityCheckData, N, m) # параллельная версия sapply
{
for (p1 in 1:UP1 ){
for (p2 in 0:UP2 ){
for (p3 in 1:UP3 ){
#вектор дельт
temp <- ret(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
return.winner<- ret.winner(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
return.loser<- ret.loser(p1, p2, p3, STEP, N, resultDataFull, UP1, UP2, percent)
n <- length(temp)
realityCheckData[m, ] <- list(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, percent,
mean(return.winner), mean(return.loser),length(temp[temp<0]))
# message(sprintf("%d", Sys.time()))
#cat(mean(temp),abs(mean(temp))/sd(temp)*sqrt(n), (1-pt(q = abs(mean(temp))/sd(temp)*sqrt(n),df = n-1))*2 ,p1*4, p2, p3*4, n, percent, mean(return.winner), mean(return.loser),length(temp[temp<0]), "\n")
m <- m+1
}
}
}
end_time <- Sys.time()
}, UP1, UP2, UP3, STEP, resultDataFull,realityCheckData, N, m)
stopCluster(cl)
#}
View(resultDataFull)
View(realityCheckData)
end_time
install.packages("plotly")
library(shiny)
install.packages("shiny")
library(RPostgreSQL)
install.packages("RPostgreSQL")
library(rCharts)
install.packages("rCharts")
install.packages("devtools")
install.packages("Rcpp")
library(devtools)
library(Rcpp)
install_github('ramnathv/rCharts')
})
library(rCharts)
createDataFunction <- function(db) {
# Замыкание над функцией получения данных из базы
createDataFunction <- function(db) {
})
})
library(shiny)
library(RPostgreSQL)
library(rCharts)
getDataFromDB <- function(query) {
# Функция получения данных по sql запросу
# Args:
#   query: sql запрос
# Returns:
#   ДатаФрейм с результатами запроса
database="ranking_automation"
conection <- dbConnect(PostgreSQL(),  user= "robot", password="robot",
dbname=database, host="ltr-cooker.dev.search.km")
sqlResults <- dbSendQuery(conection, query)
data <- fetch(sqlResults, n=-1)
dbClearResult(sqlResults)
dbDisconnect(conection)
}
##  pfPlot$xAxis(type='datetime')
